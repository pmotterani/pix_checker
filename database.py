# database.py (Vers√£o para PostgreSQL com novas fun√ß√µes de verifica√ß√£o)
"""
üóÉÔ∏è M√≥dulo de Banco de Dados
---------------------------
Respons√°vel por todas as intera√ß√µes com o banco de dados PostgreSQL.
Inclui cria√ß√£o de tabelas, CRUD de usu√°rios e transa√ß√µes.
"""
import psycopg2
from psycopg2.extras import DictCursor
import logging
from datetime import datetime, timedelta # <<< Adicionado timedelta
import config
import decimal # <<< 1. IMPORT ADDED

logger = logging.getLogger(__name__)

def get_db_connection():
    """
    Cria e retorna uma nova conex√£o com o banco de dados PostgreSQL.
    Configura o DictCursor para permitir acesso √†s colunas por nome.
    """
    try:
        conn = psycopg2.connect(config.DATABASE_URL)
        return conn
    except psycopg2.OperationalError as e:
        logger.critical(f"FATAL: N√£o foi poss√≠vel conectar ao banco de dados PostgreSQL: {e}", exc_info=True)
        raise

# Em database.py

def init_db():
    """
    Inicializa o banco de dados, criando as tabelas se n√£o existirem.
    """
    with get_db_connection() as conn:
        with conn.cursor() as cursor:
            # Tabela de Usu√°rios
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    telegram_id BIGINT PRIMARY KEY,
                    username TEXT,
                    first_name TEXT,
                    balance NUMERIC(15, 2) DEFAULT 0.00,  -- <<< ALTERADO DE REAL PARA NUMERIC
                    created_at TIMESTAMPTZ NOT NULL
                )
            ''')
            # Tabela de Transa√ß√µes
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS transactions (
                    id SERIAL PRIMARY KEY,
                    user_telegram_id BIGINT NOT NULL,
                    type TEXT NOT NULL,
                    amount NUMERIC(15, 2) NOT NULL,        -- <<< ALTERADO DE REAL PARA NUMERIC
                    status TEXT NOT NULL,
                    pix_key TEXT,
                    mercado_pago_id TEXT,
                    admin_notes TEXT,
                    created_at TIMESTAMPTZ NOT NULL,
                    updated_at TIMESTAMPTZ NOT NULL,
                    FOREIGN KEY (user_telegram_id) REFERENCES users (telegram_id)
                )
            ''')
        conn.commit()
    logger.info("‚úÖ Banco de dados PostgreSQL inicializado e verificado com sucesso.")

# <<< NOVA FUN√á√ÉO >>>
def get_pending_pix_transactions(hours=2):
    """Busca transa√ß√µes PIX pendentes das √∫ltimas 'hours' horas."""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                time_threshold = datetime.now() - timedelta(hours=hours)
                sql = """
                    SELECT * FROM transactions
                    WHERE type = 'DEPOSIT' AND status = %s AND created_at >= %s
                """
                cursor.execute(sql, (config.STATUS_DEPOSITO_PENDENTE, time_threshold))
                return cursor.fetchall()
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao buscar PIX pendentes: {e}", exc_info=True)
                return []

# <<< NOVA FUN√á√ÉO >>>
def get_transaction_by_id_and_user(transaction_id, user_telegram_id):
    """Busca uma transa√ß√£o pelo ID, garantindo que pertence ao usu√°rio."""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                cursor.execute("SELECT * FROM transactions WHERE id = %s AND user_telegram_id = %s", (transaction_id, user_telegram_id))
                return cursor.fetchone()
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao buscar transa√ß√£o {transaction_id} para usu√°rio {user_telegram_id}: {e}", exc_info=True)
                return None

# (O restante do arquivo database.py, com as outras fun√ß√µes, continua aqui sem altera√ß√µes...)
# (admin_set_balance, get_users_with_balance, create_user_if_not_exists, etc...)
def admin_set_balance(user_telegram_id, new_balance):
    """[ADMIN] Define um novo saldo para um usu√°rio."""
    with get_db_connection() as conn:
        try:
            with conn.cursor() as cursor:
                cursor.execute(
                    "UPDATE users SET balance = %s WHERE telegram_id = %s",
                    (new_balance, user_telegram_id)
                )
                if cursor.rowcount > 0:
                    record_transaction(
                        user_telegram_id=user_telegram_id, type='AJUSTE_MANUAL',
                        amount=new_balance, status='CONCLUIDO',
                        admin_notes=f"Saldo definido para R${new_balance:.2f} por um admin."
                    )
                    conn.commit()
                    return True
                return False
        except psycopg2.Error as e:
            logger.error(f"‚ùå Erro no DB ao setar saldo para {user_telegram_id}: {e}", exc_info=True)
            conn.rollback()
            return False

def get_users_with_balance():
    """[ADMIN] Retorna todos os usu√°rios com saldo maior que zero."""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                cursor.execute("SELECT telegram_id, first_name, username, balance FROM users WHERE balance > 0 ORDER BY balance DESC")
                return cursor.fetchall()
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao buscar usu√°rios com saldo: {e}", exc_info=True)
                return []

def create_user_if_not_exists(telegram_id, username, first_name):
    """Cria um novo usu√°rio se ele n√£o existir."""
    now = datetime.now()
    with get_db_connection() as conn:
        try:
            with conn.cursor() as cursor:
                sql = """
                    INSERT INTO users (telegram_id, username, first_name, balance, created_at)
                    VALUES (%s, %s, %s, 0.00, %s)
                    ON CONFLICT (telegram_id) DO NOTHING;
                """
                cursor.execute(sql, (telegram_id, username, first_name, now))
                if cursor.rowcount > 0:
                    logger.info(f"üë§ Novo usu√°rio criado: ID={telegram_id}, Nome='{first_name}'.")
            conn.commit()
        except psycopg2.Error as e:
            logger.error(f"‚ùå Erro ao tentar criar usu√°rio {telegram_id}: {e}", exc_info=True)
            conn.rollback()

def get_balance(telegram_id):
    """Busca e retorna o saldo de um usu√°rio."""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                cursor.execute("SELECT balance FROM users WHERE telegram_id = %s", (telegram_id,))
                result = cursor.fetchone()
                return result['balance'] if result else 0.00
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao buscar saldo para {telegram_id}: {e}", exc_info=True)
                return 0.00

def update_balance(telegram_id, amount_change, conn_ext=None):
    """Atualiza o saldo de um usu√°rio."""
    conn = conn_ext or get_db_connection()
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            cursor.execute("SELECT balance FROM users WHERE telegram_id = %s FOR UPDATE", (telegram_id,))
            result = cursor.fetchone()
            
            # <<< 2. MODIFIED BLOCK START >>>
            current_balance = result['balance'] if result else decimal.Decimal('0.00')
            
            # Convert float to Decimal for safe addition/subtraction
            decimal_amount_change = decimal.Decimal(str(amount_change))
            new_balance = current_balance + decimal_amount_change
            
            if new_balance < 0:
                logger.warning(f"‚ö†Ô∏è Tentativa de deixar saldo negativo para {telegram_id}.")
                # Do not rollback here, just signal failure
                return False
            # <<< MODIFIED BLOCK END >>>

            cursor.execute("UPDATE users SET balance = %s WHERE telegram_id = %s", (new_balance, telegram_id))
            if not conn_ext: conn.commit()
            logger.info(f"üí∞ Saldo de {telegram_id} atualizado. De R${current_balance:.2f} para R${new_balance:.2f} (Mudan√ßa: {amount_change:+.2f}).")
            return True
    except psycopg2.Error as e:
        logger.error(f"‚ùå Erro ao atualizar saldo para {telegram_id}: {e}", exc_info=True)
        if conn_ext is None and conn: conn.rollback()
        return False
    finally:
        if conn_ext is None and conn: conn.close()

def update_transaction_status(transaction_id, new_status, **kwargs):
    """Atualiza o status e outros campos de uma transa√ß√£o."""
    # <<< 1. FIX: Apply the same logic here.
    is_external_conn = 'conn_ext' in kwargs
    conn = kwargs.pop('conn_ext') if is_external_conn else get_db_connection()

    fields_to_update = ["status = %s", "updated_at = %s"]
    values = [new_status, datetime.now()]
    if 'mp_id' in kwargs:
        fields_to_update.append("mercado_pago_id = %s")
        values.append(kwargs['mp_id'])
    if 'admin_notes' in kwargs:
        fields_to_update.append("admin_notes = %s")
        values.append(kwargs['admin_notes'])
    values.append(transaction_id)
    try:
        with conn.cursor() as cursor:
            sql = f"UPDATE transactions SET {', '.join(fields_to_update)} WHERE id = %s"
            cursor.execute(sql, tuple(values))
            
            # <<< 2. FIX: Use the boolean flag here as well.
            if not is_external_conn:
                conn.commit()
                
        logger.info(f"üîÑ Status da transa√ß√£o {transaction_id} atualizado para '{new_status}'.")
        return True
    except psycopg2.Error as e:
        logger.error(f"‚ùå Erro ao atualizar status da transa√ß√£o {transaction_id}: {e}", exc_info=True)
        if not is_external_conn and conn:
            conn.rollback()
        return False
    finally:
        if not is_external_conn and conn:
            conn.close()

def record_transaction(**kwargs):
    """Registra uma nova transa√ß√£o no banco de dados."""
    # <<< 1. FIX: Check for the external connection BEFORE removing it from kwargs.
    is_external_conn = 'conn_ext' in kwargs
    conn = kwargs.pop('conn_ext') if is_external_conn else get_db_connection()
    
    now = datetime.now()
    kwargs.setdefault('pix_key', None); kwargs.setdefault('mercado_pago_id', None); kwargs.setdefault('admin_notes', None)
    kwargs['created_at'] = now; kwargs['updated_at'] = now
    try:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            columns = ', '.join(kwargs.keys())
            placeholders = ', '.join(['%s'] * len(kwargs))
            sql = f"INSERT INTO transactions ({columns}) VALUES ({placeholders}) RETURNING id"
            cursor.execute(sql, tuple(kwargs.values()))
            transaction_id = cursor.fetchone()['id']
            
            # <<< 2. FIX: Use the boolean flag to decide whether to commit.
            if not is_external_conn:
                conn.commit()
                
            logger.info(f"üìÑ Transa√ß√£o {transaction_id} (Tipo: {kwargs['type']}) registrada para usu√°rio {kwargs['user_telegram_id']}.")
            return transaction_id
    except psycopg2.Error as e:
        logger.error(f"‚ùå Erro ao registrar transa√ß√£o para {kwargs.get('user_telegram_id')}: {e}", exc_info=True)
        if not is_external_conn and conn:
            conn.rollback()
        return None
    finally:
        if not is_external_conn and conn:
            conn.close()

def get_transaction_details(transaction_id):
    """Busca todos os detalhes de uma transa√ß√£o pelo seu ID."""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                cursor.execute("SELECT * FROM transactions WHERE id = %s", (transaction_id,))
                return cursor.fetchone()
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao buscar detalhes da transa√ß√£o {transaction_id}: {e}", exc_info=True)
                return None

def get_pending_withdrawals():
    """Retorna todas as transa√ß√µes de saque com status 'EM AN√ÅLISE'."""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                cursor.execute("SELECT * FROM transactions WHERE type = 'WITHDRAWAL' AND status = %s", (config.STATUS_EM_ANALISE,))
                return cursor.fetchall()
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao buscar saques pendentes: {e}", exc_info=True)
                return []

def calculate_profits():
    """
    Calcula o lucro total somando as taxas de transa√ß√µes CONCLU√çDAS.
    - Taxas de dep√≥sito s√£o contadas diretamente.
    - Taxas de saque s√£o contadas apenas se o saque correspondente foi conclu√≠do.
    """
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                # Esta consulta SQL usa uma subconsulta para garantir que apenas as taxas
                # de saques bem-sucedidos sejam inclu√≠das no c√°lculo do lucro.
                # √â espec√≠fica para PostgreSQL devido ao uso de SUBSTRING com express√£o regular.
                sql_query = """
                    SELECT COALESCE(SUM(T1.amount), 0.00)
                    FROM transactions T1
                    WHERE T1.type = 'FEE' AND T1.status = %s AND (
                        -- Sempre conta as taxas de dep√≥sito, pois s√£o criadas no sucesso.
                        T1.admin_notes LIKE 'Taxa de dep√≥sito%%'
                        OR
                        -- S√≥ conta taxas de saque se o saque correspondente foi CONCLU√çDO.
                        (
                            T1.admin_notes LIKE 'Taxa referente ao saque ID %%'
                            AND
                            EXISTS (
                                SELECT 1
                                FROM transactions T2
                                WHERE T2.type = 'WITHDRAWAL'
                                  AND T2.status = %s
                                  -- Extrai o ID da nota e converte para integer para a correspond√™ncia.
                                  AND T2.id = CAST(substring(T1.admin_notes from '(\\d+)$') AS INTEGER)
                            )
                        )
                    )
                """
                cursor.execute(sql_query, (config.STATUS_CONCLUIDO, config.STATUS_CONCLUIDO))
                result = cursor.fetchone()
                # Retorna o resultado da soma. Se n√£o houver, retorna 0.00.
                return result[0] if result and result[0] is not None else 0.00
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao calcular lucro: {e}", exc_info=True)
                return 0.00

def get_fee_for_withdrawal(withdrawal_transaction_id):
    """Busca o valor da taxa associada a uma transa√ß√£o de saque."""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                note = f"Taxa referente ao saque ID {withdrawal_transaction_id}"
                cursor.execute("SELECT amount FROM transactions WHERE type = 'FEE' AND admin_notes = %s", (note,))
                result = cursor.fetchone()
                return result['amount'] if result else 0.00
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao buscar taxa para o saque {withdrawal_transaction_id}: {e}", exc_info=True)
                return 0.00

def get_user_info(telegram_id):
    """Busca informa√ß√µes b√°sicas de um usu√°rio."""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                cursor.execute("SELECT * FROM users WHERE telegram_id = %s", (telegram_id,))
                return cursor.fetchone()
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao buscar info do usu√°rio {telegram_id}: {e}", exc_info=True)
                return None

def get_last_transaction_date(telegram_id):
    """Busca a data da √∫ltima transa√ß√£o atualizada de um usu√°rio."""
    with get_db_connection() as conn:
        with conn.cursor(cursor_factory=DictCursor) as cursor:
            try:
                cursor.execute("SELECT updated_at FROM transactions WHERE user_telegram_id = %s ORDER BY updated_at DESC LIMIT 1", (telegram_id,))
                result = cursor.fetchone()
                if result:
                    return result['updated_at'].strftime('%d/%m/%Y %H:%M')
                return "Nenhuma transa√ß√£o"
            except psycopg2.Error as e:
                logger.error(f"‚ùå Erro ao buscar √∫ltima data de transa√ß√£o para {telegram_id}: {e}", exc_info=True)
                return "Erro ao consultar"
